import corectrl::*;
import eei::*;

module core (
    clk   : input   clock                          ,
    rst   : input   reset                          ,
    membus: modport membus_if::<ILEN, XLEN>::master,
) {
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    // NOTE: if => instruction fetch
    var if_pc     : Addr;
    let if_pc_next: Addr = if_pc + 4;

    // FIFO
    struct if_fifo_type {
        addr: Addr,
        bits: Inst,
    }

    var if_fifo_wready: logic       ;
    var if_fifo_wvalid: logic       ;
    var if_fifo_wdata : if_fifo_type;
    var if_fifo_rready: logic       ;
    var if_fifo_rvalid: logic       ;
    var if_fifo_rdata : if_fifo_type;

    inst if_fifo: fifo #(
        DATA_TYPE: if_fifo_type,
        WIDTH    : 3           ,
    ) (
        clk                   ,
        rst                   ,
        wready: if_fifo_wready,
        wvalid: if_fifo_wvalid,
        wdata : if_fifo_wdata ,
        rready: if_fifo_rready,
        rvalid: if_fifo_rvalid,
        rdata : if_fifo_rdata ,
    );

    // instruction fetch processing
    always_comb {
        // Fetch an instruction when there are at least two free FIFOs
        membus.valid = if_fifo.wready_two;
        membus.addr  = if_pc;
        membus.wen   = 0;
        membus.wdata = 'x; // do not use wdata

        // always receive instructions from the FIFO
        if_fifo_rready = 1;
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    var if_is_requested: logic; // Is fetching
    var if_pc_requested: Addr ; // requested address

    always_ff {
        if_reset {
            if_pc           = 0;
            if_is_requested = 0;
            if_pc_requested = 0;
            if_fifo_wvalid  = 0;
            if_fifo_wdata   = 0;
        } else {
            // Control FIFO of IF
            if if_is_requested && membus.rvalid { // when fetched
                if_fifo_wvalid     = 1;
                if_fifo_wdata.addr = if_pc_requested;
                if_fifo_wdata.bits = membus.rdata;
            } else {
                if if_fifo_wvalid && if_fifo_wready { // when data can be stored in the FIFO
                    if_fifo_wvalid = 0;
                }
            }

            if if_is_requested {
                if membus.rvalid {
                    if_is_requested = membus.ready && membus.valid;
                    if membus.ready && membus.valid {
                        if_pc           = if_pc_next;
                        if_pc_requested = if_pc;
                    }
                }
            } else {
                if membus.ready && membus.valid {
                    if_is_requested = 1;
                    if_pc           = if_pc_next;
                    if_pc_requested = if_pc;
                }
            }
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Decode

    let inst_pc  : Addr     = if_fifo_rdata.addr;
    let inst_bits: Inst     = if_fifo_rdata.bits;
    var inst_ctrl: InstCtrl;
    var inst_imm : UIntX   ;

    inst decoder: inst_decoder (
        bits: inst_bits,
        ctrl: inst_ctrl,
        imm : inst_imm ,
    );

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Read & Define registers

    var regfile: UIntX<32>; // Registers [xlen;32]

    // Register number(e.g. x1 -> 1)
    // # NOTE: Simple implementation
    // Since the location of bits representing registers is the same for different instruction formats,
    // here we will obtain the bits of one register each time for simplicity of implementation.
    let rs1_addr: logic<5> = inst_bits[19:15];
    let rs2_addr: logic<5> = inst_bits[24:20];

    let rs1_data: UIntX = if rs1_addr == 0 { // x0 to 0
        0
    } else {
        regfile[rs1_addr]
    };
    let rs2_data: UIntX = if rs2_addr == 0 {
        0
    } else {
        regfile[rs2_addr]
    };

    always_ff {
        if_reset {
            // NOTE: In book, + 100 is done, but the operation in this place is not possible in veryl 0.13.4,
            //       so the operation should be done in the range stage.
            for i: i32 in (0 + 100)..(32 + 100) {
                regfile[i - 100] = i; // NOTE: index is 0 to 31
            }
        }
    }

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Debug

    always_ff {
        if if_fifo_rvalid {
            $display("%h : %h", inst_pc, inst_bits);
            $display("  itype(0b)   : %b", inst_ctrl.itype);
            $display("  imm(0x)     : %h", inst_imm);
            $display("  rs1[%d] : %h", rs1_addr, rs1_data);
            $display("  rs2[%d] : %h", rs2_addr, rs2_data);
        }
    }
}
